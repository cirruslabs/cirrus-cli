// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// Authenticate invokes authenticate operation.
	//
	// This endpoint returns API tokens for a given email and password.
	//
	// POST /api/auth
	Authenticate(ctx context.Context, request OptAuthenticateReq) (AuthenticateRes, error)
	// CacheArtifactExists invokes cacheArtifactExists operation.
	//
	// This endpoint checks if an artifact exists in the cache. It returns a 404 status code if the
	// artifact does not exist.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /api/cache/exists
	CacheArtifactExists(ctx context.Context, params CacheArtifactExistsParams) (CacheArtifactExistsRes, error)
	// CleanCache invokes cleanCache operation.
	//
	// Cleans cache for a given project.
	//
	// PUT /api/projects/{account_handle}/{project_handle}/cache/clean
	CleanCache(ctx context.Context, params CleanCacheParams) (CleanCacheRes, error)
	// CompleteAnalyticsArtifactMultipartUpload invokes completeAnalyticsArtifactMultipartUpload operation.
	//
	// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart
	// upload.
	//
	// POST /api/runs/{run_id}/complete
	CompleteAnalyticsArtifactMultipartUpload(ctx context.Context, request OptCompleteAnalyticsArtifactMultipartUploadReq, params CompleteAnalyticsArtifactMultipartUploadParams) (CompleteAnalyticsArtifactMultipartUploadRes, error)
	// CompleteAnalyticsArtifactsUploads invokes completeAnalyticsArtifactsUploads operation.
	//
	// Given a command event, it marks all artifact uploads as finished and does extra processing of a
	// given command run, such as test flakiness detection.
	//
	// PUT /api/runs/{run_id}/complete_artifacts_uploads
	CompleteAnalyticsArtifactsUploads(ctx context.Context, request OptCompleteAnalyticsArtifactsUploadsReq, params CompleteAnalyticsArtifactsUploadsParams) (CompleteAnalyticsArtifactsUploadsRes, error)
	// CompleteCacheArtifactMultipartUpload invokes completeCacheArtifactMultipartUpload operation.
	//
	// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart
	// upload. The cache will then be able to serve the artifact.
	//
	// POST /api/cache/multipart/complete
	CompleteCacheArtifactMultipartUpload(ctx context.Context, request OptCompleteCacheArtifactMultipartUploadReq, params CompleteCacheArtifactMultipartUploadParams) (CompleteCacheArtifactMultipartUploadRes, error)
	// CompletePreviewsMultipartUpload invokes completePreviewsMultipartUpload operation.
	//
	// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart
	// upload.
	//
	// POST /api/projects/{account_handle}/{project_handle}/previews/complete
	CompletePreviewsMultipartUpload(ctx context.Context, request OptCompletePreviewsMultipartUploadReq, params CompletePreviewsMultipartUploadParams) (CompletePreviewsMultipartUploadRes, error)
	// CreateCommandEvent invokes createCommandEvent operation.
	//
	// Create a a new command analytics event.
	//
	// POST /api/analytics
	CreateCommandEvent(ctx context.Context, request OptCreateCommandEventReq, params CreateCommandEventParams) (CreateCommandEventRes, error)
	// CreateInvitation invokes createInvitation operation.
	//
	// Invites a user with a given email to a given organization.
	//
	// POST /api/organizations/{organization_name}/invitations
	CreateInvitation(ctx context.Context, request OptCreateInvitationReq, params CreateInvitationParams) (CreateInvitationRes, error)
	// CreateOrganization invokes createOrganization operation.
	//
	// Creates an organization with the given name.
	//
	// POST /api/organizations
	CreateOrganization(ctx context.Context, request OptCreateOrganizationReq) (CreateOrganizationRes, error)
	// CreateProject invokes createProject operation.
	//
	// Create a new project.
	//
	// POST /api/projects
	CreateProject(ctx context.Context, request OptCreateProjectReq) (CreateProjectRes, error)
	// CreateProjectToken invokes createProjectToken operation.
	//
	// This endpoint returns a new project token.
	//
	// POST /api/projects/{account_handle}/{project_handle}/tokens
	CreateProjectToken(ctx context.Context, params CreateProjectTokenParams) (CreateProjectTokenRes, error)
	// DeleteOrganization invokes deleteOrganization operation.
	//
	// Deletes the organization with the given name.
	//
	// DELETE /api/organizations/{organization_name}
	DeleteOrganization(ctx context.Context, params DeleteOrganizationParams) (DeleteOrganizationRes, error)
	// DeleteProject invokes deleteProject operation.
	//
	// Deletes a project with a given id.
	//
	// DELETE /api/projects/{id}
	DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error)
	// DownloadCacheArtifact invokes downloadCacheArtifact operation.
	//
	// This endpoint returns a signed URL that can be used to download an artifact from the cache.
	//
	// GET /api/cache
	DownloadCacheArtifact(ctx context.Context, params DownloadCacheArtifactParams) (DownloadCacheArtifactRes, error)
	// DownloadPreview invokes downloadPreview operation.
	//
	// This endpoint returns a signed URL that can be used to download a preview.
	//
	// GET /api/projects/{account_handle}/{project_handle}/previews/{preview_id}
	DownloadPreview(ctx context.Context, params DownloadPreviewParams) (DownloadPreviewRes, error)
	// GenerateAnalyticsArtifactMultipartUploadURL invokes generateAnalyticsArtifactMultipartUploadURL operation.
	//
	// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to
	// upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
	//
	// POST /api/runs/{run_id}/generate-url
	GenerateAnalyticsArtifactMultipartUploadURL(ctx context.Context, request OptGenerateAnalyticsArtifactMultipartUploadURLReq, params GenerateAnalyticsArtifactMultipartUploadURLParams) (GenerateAnalyticsArtifactMultipartUploadURLRes, error)
	// GenerateCacheArtifactMultipartUploadURL invokes generateCacheArtifactMultipartUploadURL operation.
	//
	// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to
	// upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
	//
	// POST /api/cache/multipart/generate-url
	GenerateCacheArtifactMultipartUploadURL(ctx context.Context, params GenerateCacheArtifactMultipartUploadURLParams) (GenerateCacheArtifactMultipartUploadURLRes, error)
	// GeneratePreviewsMultipartUploadURL invokes generatePreviewsMultipartUploadURL operation.
	//
	// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to
	// upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
	//
	// POST /api/projects/{account_handle}/{project_handle}/previews/generate-url
	GeneratePreviewsMultipartUploadURL(ctx context.Context, request OptGeneratePreviewsMultipartUploadURLReq, params GeneratePreviewsMultipartUploadURLParams) (GeneratePreviewsMultipartUploadURLRes, error)
	// GetCacheActionItem invokes getCacheActionItem operation.
	//
	// This endpoint gets an item from the action cache.
	//
	// GET /api/projects/{account_handle}/{project_handle}/cache/ac/{hash}
	GetCacheActionItem(ctx context.Context, params GetCacheActionItemParams) (GetCacheActionItemRes, error)
	// GetDeviceCode invokes getDeviceCode operation.
	//
	// This endpoint returns a token for a given device code if the device code is authenticated.
	//
	// GET /api/auth/device_code/{device_code}
	GetDeviceCode(ctx context.Context, params GetDeviceCodeParams) (GetDeviceCodeRes, error)
	// ListOrganizations invokes listOrganizations operation.
	//
	// Returns all the organizations the authenticated subject is part of.
	//
	// GET /api/organizations
	ListOrganizations(ctx context.Context) (ListOrganizationsRes, error)
	// ListProjectTokens invokes listProjectTokens operation.
	//
	// This endpoint returns all tokens for a given project.
	//
	// GET /api/projects/{account_handle}/{project_handle}/tokens
	ListProjectTokens(ctx context.Context, params ListProjectTokensParams) (ListProjectTokensRes, error)
	// ListProjects invokes listProjects operation.
	//
	// List projects the authenticated user has access to.
	//
	// GET /api/projects
	ListProjects(ctx context.Context) (ListProjectsRes, error)
	// RefreshToken invokes refreshToken operation.
	//
	// This endpoint returns new tokens for a given refresh token if the refresh token is valid.
	//
	// POST /api/auth/refresh_token
	RefreshToken(ctx context.Context, request OptRefreshTokenReq) (RefreshTokenRes, error)
	// RevokeProjectToken invokes revokeProjectToken operation.
	//
	// Revokes a project token.
	//
	// DELETE /api/projects/{account_handle}/{project_handle}/tokens/{id}
	RevokeProjectToken(ctx context.Context, params RevokeProjectTokenParams) (RevokeProjectTokenRes, error)
	// ShowOrganization invokes showOrganization operation.
	//
	// Returns the organization with the given identifier.
	//
	// GET /api/organizations/{organization_name}
	ShowOrganization(ctx context.Context, params ShowOrganizationParams) (ShowOrganizationRes, error)
	// ShowOrganizationUsage invokes showOrganizationUsage operation.
	//
	// Returns the usage of the organization with the given identifier. (e.g. number of remote cache hits).
	//
	// GET /api/organizations/{organization_name}/usage
	ShowOrganizationUsage(ctx context.Context, params ShowOrganizationUsageParams) (ShowOrganizationUsageRes, error)
	// ShowProject invokes showProject operation.
	//
	// Returns a project based on the handle.
	//
	// GET /api/projects/{account_handle}/{project_handle}
	ShowProject(ctx context.Context, params ShowProjectParams) (ShowProjectRes, error)
	// StartAnalyticsArtifactMultipartUpload invokes startAnalyticsArtifactMultipartUpload operation.
	//
	// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and
	// complete the upload.
	//
	// POST /api/runs/{run_id}/start
	StartAnalyticsArtifactMultipartUpload(ctx context.Context, request CommandEventArtifact, params StartAnalyticsArtifactMultipartUploadParams) (StartAnalyticsArtifactMultipartUploadRes, error)
	// StartCacheArtifactMultipartUpload invokes startCacheArtifactMultipartUpload operation.
	//
	// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and
	// complete the upload.
	//
	// POST /api/cache/multipart/start
	StartCacheArtifactMultipartUpload(ctx context.Context, params StartCacheArtifactMultipartUploadParams) (StartCacheArtifactMultipartUploadRes, error)
	// StartPreviewsMultipartUpload invokes startPreviewsMultipartUpload operation.
	//
	// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and
	// complete the upload.
	//
	// POST /api/projects/{account_handle}/{project_handle}/previews/start
	StartPreviewsMultipartUpload(ctx context.Context, request OptStartPreviewsMultipartUploadReq, params StartPreviewsMultipartUploadParams) (StartPreviewsMultipartUploadRes, error)
	// UpdateOrganization invokes updateOrganization operation.
	//
	// Updates an organization with given parameters.
	//
	// PUT /api/organizations/{organization_name}
	UpdateOrganization(ctx context.Context, request OptUpdateOrganizationReq, params UpdateOrganizationParams) (UpdateOrganizationRes, error)
	// UpdateOrganization2 invokes updateOrganization (2) operation.
	//
	// Updates an organization with given parameters.
	//
	// PATCH /api/organizations/{organization_name}
	UpdateOrganization2(ctx context.Context, request OptUpdateOrganization2Req, params UpdateOrganization2Params) (UpdateOrganization2Res, error)
	// UpdateOrganizationMember invokes updateOrganizationMember operation.
	//
	// Updates a member in a given organization.
	//
	// PUT /api/organizations/{organization_name}/members/{user_name}
	UpdateOrganizationMember(ctx context.Context, request OptUpdateOrganizationMemberReq, params UpdateOrganizationMemberParams) (UpdateOrganizationMemberRes, error)
	// UpdateProject invokes updateProject operation.
	//
	// Updates a project with given parameters.
	//
	// PUT /api/projects/{account_handle}/{project_handle}
	UpdateProject(ctx context.Context, request OptUpdateProjectReq, params UpdateProjectParams) (UpdateProjectRes, error)
	// UploadCacheActionItem invokes uploadCacheActionItem operation.
	//
	// The endpoint caches a given action item without uploading a file. To upload files, use the
	// multipart upload instead.
	//
	// POST /api/projects/{account_handle}/{project_handle}/cache/ac
	UploadCacheActionItem(ctx context.Context, request OptUploadCacheActionItemReq, params UploadCacheActionItemParams) (UploadCacheActionItemRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// Authenticate invokes authenticate operation.
//
// This endpoint returns API tokens for a given email and password.
//
// POST /api/auth
func (c *Client) Authenticate(ctx context.Context, request OptAuthenticateReq) (AuthenticateRes, error) {
	res, err := c.sendAuthenticate(ctx, request)
	return res, err
}

func (c *Client) sendAuthenticate(ctx context.Context, request OptAuthenticateReq) (res AuthenticateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("authenticate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/auth"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Authenticate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/auth"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthenticateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "Authenticate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "Authenticate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAuthenticateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CacheArtifactExists invokes cacheArtifactExists operation.
//
// This endpoint checks if an artifact exists in the cache. It returns a 404 status code if the
// artifact does not exist.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /api/cache/exists
func (c *Client) CacheArtifactExists(ctx context.Context, params CacheArtifactExistsParams) (CacheArtifactExistsRes, error) {
	res, err := c.sendCacheArtifactExists(ctx, params)
	return res, err
}

func (c *Client) sendCacheArtifactExists(ctx context.Context, params CacheArtifactExistsParams) (res CacheArtifactExistsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cacheArtifactExists"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/cache/exists"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CacheArtifactExists",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/cache/exists"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cache_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cache_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CacheCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hash" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CacheArtifactExists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CacheArtifactExists", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCacheArtifactExistsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CleanCache invokes cleanCache operation.
//
// Cleans cache for a given project.
//
// PUT /api/projects/{account_handle}/{project_handle}/cache/clean
func (c *Client) CleanCache(ctx context.Context, params CleanCacheParams) (CleanCacheRes, error) {
	res, err := c.sendCleanCache(ctx, params)
	return res, err
}

func (c *Client) sendCleanCache(ctx context.Context, params CleanCacheParams) (res CleanCacheRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cleanCache"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/cache/clean"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CleanCache",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/cache/clean"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CleanCache", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CleanCache", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCleanCacheResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompleteAnalyticsArtifactMultipartUpload invokes completeAnalyticsArtifactMultipartUpload operation.
//
// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart
// upload.
//
// POST /api/runs/{run_id}/complete
func (c *Client) CompleteAnalyticsArtifactMultipartUpload(ctx context.Context, request OptCompleteAnalyticsArtifactMultipartUploadReq, params CompleteAnalyticsArtifactMultipartUploadParams) (CompleteAnalyticsArtifactMultipartUploadRes, error) {
	res, err := c.sendCompleteAnalyticsArtifactMultipartUpload(ctx, request, params)
	return res, err
}

func (c *Client) sendCompleteAnalyticsArtifactMultipartUpload(ctx context.Context, request OptCompleteAnalyticsArtifactMultipartUploadReq, params CompleteAnalyticsArtifactMultipartUploadParams) (res CompleteAnalyticsArtifactMultipartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("completeAnalyticsArtifactMultipartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/runs/{run_id}/complete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CompleteAnalyticsArtifactMultipartUpload",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/complete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompleteAnalyticsArtifactMultipartUploadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CompleteAnalyticsArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CompleteAnalyticsArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCompleteAnalyticsArtifactMultipartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompleteAnalyticsArtifactsUploads invokes completeAnalyticsArtifactsUploads operation.
//
// Given a command event, it marks all artifact uploads as finished and does extra processing of a
// given command run, such as test flakiness detection.
//
// PUT /api/runs/{run_id}/complete_artifacts_uploads
func (c *Client) CompleteAnalyticsArtifactsUploads(ctx context.Context, request OptCompleteAnalyticsArtifactsUploadsReq, params CompleteAnalyticsArtifactsUploadsParams) (CompleteAnalyticsArtifactsUploadsRes, error) {
	res, err := c.sendCompleteAnalyticsArtifactsUploads(ctx, request, params)
	return res, err
}

func (c *Client) sendCompleteAnalyticsArtifactsUploads(ctx context.Context, request OptCompleteAnalyticsArtifactsUploadsReq, params CompleteAnalyticsArtifactsUploadsParams) (res CompleteAnalyticsArtifactsUploadsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("completeAnalyticsArtifactsUploads"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/runs/{run_id}/complete_artifacts_uploads"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CompleteAnalyticsArtifactsUploads",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/complete_artifacts_uploads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompleteAnalyticsArtifactsUploadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CompleteAnalyticsArtifactsUploads", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CompleteAnalyticsArtifactsUploads", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCompleteAnalyticsArtifactsUploadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompleteCacheArtifactMultipartUpload invokes completeCacheArtifactMultipartUpload operation.
//
// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart
// upload. The cache will then be able to serve the artifact.
//
// POST /api/cache/multipart/complete
func (c *Client) CompleteCacheArtifactMultipartUpload(ctx context.Context, request OptCompleteCacheArtifactMultipartUploadReq, params CompleteCacheArtifactMultipartUploadParams) (CompleteCacheArtifactMultipartUploadRes, error) {
	res, err := c.sendCompleteCacheArtifactMultipartUpload(ctx, request, params)
	return res, err
}

func (c *Client) sendCompleteCacheArtifactMultipartUpload(ctx context.Context, request OptCompleteCacheArtifactMultipartUploadReq, params CompleteCacheArtifactMultipartUploadParams) (res CompleteCacheArtifactMultipartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("completeCacheArtifactMultipartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/cache/multipart/complete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CompleteCacheArtifactMultipartUpload",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/cache/multipart/complete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cache_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cache_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CacheCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hash" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "upload_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "upload_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.UploadID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompleteCacheArtifactMultipartUploadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CompleteCacheArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CompleteCacheArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCompleteCacheArtifactMultipartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompletePreviewsMultipartUpload invokes completePreviewsMultipartUpload operation.
//
// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart
// upload.
//
// POST /api/projects/{account_handle}/{project_handle}/previews/complete
func (c *Client) CompletePreviewsMultipartUpload(ctx context.Context, request OptCompletePreviewsMultipartUploadReq, params CompletePreviewsMultipartUploadParams) (CompletePreviewsMultipartUploadRes, error) {
	res, err := c.sendCompletePreviewsMultipartUpload(ctx, request, params)
	return res, err
}

func (c *Client) sendCompletePreviewsMultipartUpload(ctx context.Context, request OptCompletePreviewsMultipartUploadReq, params CompletePreviewsMultipartUploadParams) (res CompletePreviewsMultipartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("completePreviewsMultipartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/previews/complete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CompletePreviewsMultipartUpload",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/previews/complete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompletePreviewsMultipartUploadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CompletePreviewsMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CompletePreviewsMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCompletePreviewsMultipartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCommandEvent invokes createCommandEvent operation.
//
// Create a a new command analytics event.
//
// POST /api/analytics
func (c *Client) CreateCommandEvent(ctx context.Context, request OptCreateCommandEventReq, params CreateCommandEventParams) (CreateCommandEventRes, error) {
	res, err := c.sendCreateCommandEvent(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateCommandEvent(ctx context.Context, request OptCreateCommandEventReq, params CreateCommandEventParams) (res CreateCommandEventRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createCommandEvent"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/analytics"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateCommandEvent",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/analytics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCommandEventRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CreateCommandEvent", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CreateCommandEvent", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateCommandEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateInvitation invokes createInvitation operation.
//
// Invites a user with a given email to a given organization.
//
// POST /api/organizations/{organization_name}/invitations
func (c *Client) CreateInvitation(ctx context.Context, request OptCreateInvitationReq, params CreateInvitationParams) (CreateInvitationRes, error) {
	res, err := c.sendCreateInvitation(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateInvitation(ctx context.Context, request OptCreateInvitationReq, params CreateInvitationParams) (res CreateInvitationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createInvitation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/organizations/{organization_name}/invitations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateInvitation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/organizations/"
	{
		// Encode "organization_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organization_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invitations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateInvitationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CreateInvitation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CreateInvitation", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOrganization invokes createOrganization operation.
//
// Creates an organization with the given name.
//
// POST /api/organizations
func (c *Client) CreateOrganization(ctx context.Context, request OptCreateOrganizationReq) (CreateOrganizationRes, error) {
	res, err := c.sendCreateOrganization(ctx, request)
	return res, err
}

func (c *Client) sendCreateOrganization(ctx context.Context, request OptCreateOrganizationReq) (res CreateOrganizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createOrganization"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/organizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOrganizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CreateOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CreateOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProject invokes createProject operation.
//
// Create a new project.
//
// POST /api/projects
func (c *Client) CreateProject(ctx context.Context, request OptCreateProjectReq) (CreateProjectRes, error) {
	res, err := c.sendCreateProject(ctx, request)
	return res, err
}

func (c *Client) sendCreateProject(ctx context.Context, request OptCreateProjectReq) (res CreateProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createProject"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateProject",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CreateProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CreateProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProjectToken invokes createProjectToken operation.
//
// This endpoint returns a new project token.
//
// POST /api/projects/{account_handle}/{project_handle}/tokens
func (c *Client) CreateProjectToken(ctx context.Context, params CreateProjectTokenParams) (CreateProjectTokenRes, error) {
	res, err := c.sendCreateProjectToken(ctx, params)
	return res, err
}

func (c *Client) sendCreateProjectToken(ctx context.Context, params CreateProjectTokenParams) (res CreateProjectTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createProjectToken"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateProjectToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "CreateProjectToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "CreateProjectToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateProjectTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteOrganization invokes deleteOrganization operation.
//
// Deletes the organization with the given name.
//
// DELETE /api/organizations/{organization_name}
func (c *Client) DeleteOrganization(ctx context.Context, params DeleteOrganizationParams) (DeleteOrganizationRes, error) {
	res, err := c.sendDeleteOrganization(ctx, params)
	return res, err
}

func (c *Client) sendDeleteOrganization(ctx context.Context, params DeleteOrganizationParams) (res DeleteOrganizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteOrganization"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/organizations/{organization_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/organizations/"
	{
		// Encode "organization_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organization_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "DeleteOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "DeleteOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProject invokes deleteProject operation.
//
// Deletes a project with a given id.
//
// DELETE /api/projects/{id}
func (c *Client) DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error) {
	res, err := c.sendDeleteProject(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProject(ctx context.Context, params DeleteProjectParams) (res DeleteProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteProject"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/projects/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteProject",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "DeleteProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "DeleteProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DownloadCacheArtifact invokes downloadCacheArtifact operation.
//
// This endpoint returns a signed URL that can be used to download an artifact from the cache.
//
// GET /api/cache
func (c *Client) DownloadCacheArtifact(ctx context.Context, params DownloadCacheArtifactParams) (DownloadCacheArtifactRes, error) {
	res, err := c.sendDownloadCacheArtifact(ctx, params)
	return res, err
}

func (c *Client) sendDownloadCacheArtifact(ctx context.Context, params DownloadCacheArtifactParams) (res DownloadCacheArtifactRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("downloadCacheArtifact"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/cache"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DownloadCacheArtifact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/cache"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cache_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cache_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CacheCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hash" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "DownloadCacheArtifact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "DownloadCacheArtifact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDownloadCacheArtifactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DownloadPreview invokes downloadPreview operation.
//
// This endpoint returns a signed URL that can be used to download a preview.
//
// GET /api/projects/{account_handle}/{project_handle}/previews/{preview_id}
func (c *Client) DownloadPreview(ctx context.Context, params DownloadPreviewParams) (DownloadPreviewRes, error) {
	res, err := c.sendDownloadPreview(ctx, params)
	return res, err
}

func (c *Client) sendDownloadPreview(ctx context.Context, params DownloadPreviewParams) (res DownloadPreviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("downloadPreview"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/previews/{preview_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DownloadPreview",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/previews/"
	{
		// Encode "preview_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "preview_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PreviewID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "DownloadPreview", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "DownloadPreview", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDownloadPreviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateAnalyticsArtifactMultipartUploadURL invokes generateAnalyticsArtifactMultipartUploadURL operation.
//
// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to
// upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
//
// POST /api/runs/{run_id}/generate-url
func (c *Client) GenerateAnalyticsArtifactMultipartUploadURL(ctx context.Context, request OptGenerateAnalyticsArtifactMultipartUploadURLReq, params GenerateAnalyticsArtifactMultipartUploadURLParams) (GenerateAnalyticsArtifactMultipartUploadURLRes, error) {
	res, err := c.sendGenerateAnalyticsArtifactMultipartUploadURL(ctx, request, params)
	return res, err
}

func (c *Client) sendGenerateAnalyticsArtifactMultipartUploadURL(ctx context.Context, request OptGenerateAnalyticsArtifactMultipartUploadURLReq, params GenerateAnalyticsArtifactMultipartUploadURLParams) (res GenerateAnalyticsArtifactMultipartUploadURLRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generateAnalyticsArtifactMultipartUploadURL"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/runs/{run_id}/generate-url"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GenerateAnalyticsArtifactMultipartUploadURL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/generate-url"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateAnalyticsArtifactMultipartUploadURLRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "GenerateAnalyticsArtifactMultipartUploadURL", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "GenerateAnalyticsArtifactMultipartUploadURL", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGenerateAnalyticsArtifactMultipartUploadURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateCacheArtifactMultipartUploadURL invokes generateCacheArtifactMultipartUploadURL operation.
//
// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to
// upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
//
// POST /api/cache/multipart/generate-url
func (c *Client) GenerateCacheArtifactMultipartUploadURL(ctx context.Context, params GenerateCacheArtifactMultipartUploadURLParams) (GenerateCacheArtifactMultipartUploadURLRes, error) {
	res, err := c.sendGenerateCacheArtifactMultipartUploadURL(ctx, params)
	return res, err
}

func (c *Client) sendGenerateCacheArtifactMultipartUploadURL(ctx context.Context, params GenerateCacheArtifactMultipartUploadURLParams) (res GenerateCacheArtifactMultipartUploadURLRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generateCacheArtifactMultipartUploadURL"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/cache/multipart/generate-url"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GenerateCacheArtifactMultipartUploadURL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/cache/multipart/generate-url"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cache_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cache_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CacheCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hash" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "part_number" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "part_number",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.PartNumber))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "upload_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "upload_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.UploadID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "GenerateCacheArtifactMultipartUploadURL", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "GenerateCacheArtifactMultipartUploadURL", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGenerateCacheArtifactMultipartUploadURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GeneratePreviewsMultipartUploadURL invokes generatePreviewsMultipartUploadURL operation.
//
// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to
// upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
//
// POST /api/projects/{account_handle}/{project_handle}/previews/generate-url
func (c *Client) GeneratePreviewsMultipartUploadURL(ctx context.Context, request OptGeneratePreviewsMultipartUploadURLReq, params GeneratePreviewsMultipartUploadURLParams) (GeneratePreviewsMultipartUploadURLRes, error) {
	res, err := c.sendGeneratePreviewsMultipartUploadURL(ctx, request, params)
	return res, err
}

func (c *Client) sendGeneratePreviewsMultipartUploadURL(ctx context.Context, request OptGeneratePreviewsMultipartUploadURLReq, params GeneratePreviewsMultipartUploadURLParams) (res GeneratePreviewsMultipartUploadURLRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generatePreviewsMultipartUploadURL"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/previews/generate-url"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GeneratePreviewsMultipartUploadURL",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/previews/generate-url"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGeneratePreviewsMultipartUploadURLRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "GeneratePreviewsMultipartUploadURL", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "GeneratePreviewsMultipartUploadURL", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGeneratePreviewsMultipartUploadURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCacheActionItem invokes getCacheActionItem operation.
//
// This endpoint gets an item from the action cache.
//
// GET /api/projects/{account_handle}/{project_handle}/cache/ac/{hash}
func (c *Client) GetCacheActionItem(ctx context.Context, params GetCacheActionItemParams) (GetCacheActionItemRes, error) {
	res, err := c.sendGetCacheActionItem(ctx, params)
	return res, err
}

func (c *Client) sendGetCacheActionItem(ctx context.Context, params GetCacheActionItemParams) (res GetCacheActionItemRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCacheActionItem"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/cache/ac/{hash}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCacheActionItem",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/cache/ac/"
	{
		// Encode "hash" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hash",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "GetCacheActionItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "GetCacheActionItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCacheActionItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDeviceCode invokes getDeviceCode operation.
//
// This endpoint returns a token for a given device code if the device code is authenticated.
//
// GET /api/auth/device_code/{device_code}
func (c *Client) GetDeviceCode(ctx context.Context, params GetDeviceCodeParams) (GetDeviceCodeRes, error) {
	res, err := c.sendGetDeviceCode(ctx, params)
	return res, err
}

func (c *Client) sendGetDeviceCode(ctx context.Context, params GetDeviceCodeParams) (res GetDeviceCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDeviceCode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/auth/device_code/{device_code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDeviceCode",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/auth/device_code/"
	{
		// Encode "device_code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "device_code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DeviceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "GetDeviceCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "GetDeviceCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDeviceCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrganizations invokes listOrganizations operation.
//
// Returns all the organizations the authenticated subject is part of.
//
// GET /api/organizations
func (c *Client) ListOrganizations(ctx context.Context) (ListOrganizationsRes, error) {
	res, err := c.sendListOrganizations(ctx)
	return res, err
}

func (c *Client) sendListOrganizations(ctx context.Context) (res ListOrganizationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listOrganizations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/organizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListOrganizations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "ListOrganizations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "ListOrganizations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrganizationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProjectTokens invokes listProjectTokens operation.
//
// This endpoint returns all tokens for a given project.
//
// GET /api/projects/{account_handle}/{project_handle}/tokens
func (c *Client) ListProjectTokens(ctx context.Context, params ListProjectTokensParams) (ListProjectTokensRes, error) {
	res, err := c.sendListProjectTokens(ctx, params)
	return res, err
}

func (c *Client) sendListProjectTokens(ctx context.Context, params ListProjectTokensParams) (res ListProjectTokensRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listProjectTokens"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListProjectTokens",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "ListProjectTokens", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "ListProjectTokens", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListProjectTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProjects invokes listProjects operation.
//
// List projects the authenticated user has access to.
//
// GET /api/projects
func (c *Client) ListProjects(ctx context.Context) (ListProjectsRes, error) {
	res, err := c.sendListProjects(ctx)
	return res, err
}

func (c *Client) sendListProjects(ctx context.Context) (res ListProjectsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listProjects"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/projects"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListProjects",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "ListProjects", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "ListProjects", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RefreshToken invokes refreshToken operation.
//
// This endpoint returns new tokens for a given refresh token if the refresh token is valid.
//
// POST /api/auth/refresh_token
func (c *Client) RefreshToken(ctx context.Context, request OptRefreshTokenReq) (RefreshTokenRes, error) {
	res, err := c.sendRefreshToken(ctx, request)
	return res, err
}

func (c *Client) sendRefreshToken(ctx context.Context, request OptRefreshTokenReq) (res RefreshTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("refreshToken"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/auth/refresh_token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RefreshToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/auth/refresh_token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRefreshTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "RefreshToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "RefreshToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRefreshTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeProjectToken invokes revokeProjectToken operation.
//
// Revokes a project token.
//
// DELETE /api/projects/{account_handle}/{project_handle}/tokens/{id}
func (c *Client) RevokeProjectToken(ctx context.Context, params RevokeProjectTokenParams) (RevokeProjectTokenRes, error) {
	res, err := c.sendRevokeProjectToken(ctx, params)
	return res, err
}

func (c *Client) sendRevokeProjectToken(ctx context.Context, params RevokeProjectTokenParams) (res RevokeProjectTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("revokeProjectToken"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/tokens/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RevokeProjectToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tokens/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "RevokeProjectToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "RevokeProjectToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRevokeProjectTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShowOrganization invokes showOrganization operation.
//
// Returns the organization with the given identifier.
//
// GET /api/organizations/{organization_name}
func (c *Client) ShowOrganization(ctx context.Context, params ShowOrganizationParams) (ShowOrganizationRes, error) {
	res, err := c.sendShowOrganization(ctx, params)
	return res, err
}

func (c *Client) sendShowOrganization(ctx context.Context, params ShowOrganizationParams) (res ShowOrganizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("showOrganization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/organizations/{organization_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ShowOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/organizations/"
	{
		// Encode "organization_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organization_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "ShowOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "ShowOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeShowOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShowOrganizationUsage invokes showOrganizationUsage operation.
//
// Returns the usage of the organization with the given identifier. (e.g. number of remote cache hits).
//
// GET /api/organizations/{organization_name}/usage
func (c *Client) ShowOrganizationUsage(ctx context.Context, params ShowOrganizationUsageParams) (ShowOrganizationUsageRes, error) {
	res, err := c.sendShowOrganizationUsage(ctx, params)
	return res, err
}

func (c *Client) sendShowOrganizationUsage(ctx context.Context, params ShowOrganizationUsageParams) (res ShowOrganizationUsageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("showOrganizationUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/organizations/{organization_name}/usage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ShowOrganizationUsage",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/organizations/"
	{
		// Encode "organization_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organization_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/usage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "ShowOrganizationUsage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "ShowOrganizationUsage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeShowOrganizationUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShowProject invokes showProject operation.
//
// Returns a project based on the handle.
//
// GET /api/projects/{account_handle}/{project_handle}
func (c *Client) ShowProject(ctx context.Context, params ShowProjectParams) (ShowProjectRes, error) {
	res, err := c.sendShowProject(ctx, params)
	return res, err
}

func (c *Client) sendShowProject(ctx context.Context, params ShowProjectParams) (res ShowProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("showProject"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ShowProject",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "ShowProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "ShowProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeShowProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartAnalyticsArtifactMultipartUpload invokes startAnalyticsArtifactMultipartUpload operation.
//
// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and
// complete the upload.
//
// POST /api/runs/{run_id}/start
func (c *Client) StartAnalyticsArtifactMultipartUpload(ctx context.Context, request CommandEventArtifact, params StartAnalyticsArtifactMultipartUploadParams) (StartAnalyticsArtifactMultipartUploadRes, error) {
	res, err := c.sendStartAnalyticsArtifactMultipartUpload(ctx, request, params)
	return res, err
}

func (c *Client) sendStartAnalyticsArtifactMultipartUpload(ctx context.Context, request CommandEventArtifact, params StartAnalyticsArtifactMultipartUploadParams) (res StartAnalyticsArtifactMultipartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("startAnalyticsArtifactMultipartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/runs/{run_id}/start"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StartAnalyticsArtifactMultipartUpload",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/runs/"
	{
		// Encode "run_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RunID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/start"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartAnalyticsArtifactMultipartUploadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "StartAnalyticsArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "StartAnalyticsArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStartAnalyticsArtifactMultipartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCacheArtifactMultipartUpload invokes startCacheArtifactMultipartUpload operation.
//
// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and
// complete the upload.
//
// POST /api/cache/multipart/start
func (c *Client) StartCacheArtifactMultipartUpload(ctx context.Context, params StartCacheArtifactMultipartUploadParams) (StartCacheArtifactMultipartUploadRes, error) {
	res, err := c.sendStartCacheArtifactMultipartUpload(ctx, params)
	return res, err
}

func (c *Client) sendStartCacheArtifactMultipartUpload(ctx context.Context, params StartCacheArtifactMultipartUploadParams) (res StartCacheArtifactMultipartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("startCacheArtifactMultipartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/cache/multipart/start"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StartCacheArtifactMultipartUpload",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/cache/multipart/start"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cache_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cache_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CacheCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hash" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "StartCacheArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "StartCacheArtifactMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStartCacheArtifactMultipartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartPreviewsMultipartUpload invokes startPreviewsMultipartUpload operation.
//
// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and
// complete the upload.
//
// POST /api/projects/{account_handle}/{project_handle}/previews/start
func (c *Client) StartPreviewsMultipartUpload(ctx context.Context, request OptStartPreviewsMultipartUploadReq, params StartPreviewsMultipartUploadParams) (StartPreviewsMultipartUploadRes, error) {
	res, err := c.sendStartPreviewsMultipartUpload(ctx, request, params)
	return res, err
}

func (c *Client) sendStartPreviewsMultipartUpload(ctx context.Context, request OptStartPreviewsMultipartUploadReq, params StartPreviewsMultipartUploadParams) (res StartPreviewsMultipartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("startPreviewsMultipartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/previews/start"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StartPreviewsMultipartUpload",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/previews/start"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartPreviewsMultipartUploadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "StartPreviewsMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "StartPreviewsMultipartUpload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStartPreviewsMultipartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOrganization invokes updateOrganization operation.
//
// Updates an organization with given parameters.
//
// PUT /api/organizations/{organization_name}
func (c *Client) UpdateOrganization(ctx context.Context, request OptUpdateOrganizationReq, params UpdateOrganizationParams) (UpdateOrganizationRes, error) {
	res, err := c.sendUpdateOrganization(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateOrganization(ctx context.Context, request OptUpdateOrganizationReq, params UpdateOrganizationParams) (res UpdateOrganizationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateOrganization"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/organizations/{organization_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/organizations/"
	{
		// Encode "organization_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organization_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOrganizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "UpdateOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "UpdateOrganization", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOrganization2 invokes updateOrganization (2) operation.
//
// Updates an organization with given parameters.
//
// PATCH /api/organizations/{organization_name}
func (c *Client) UpdateOrganization2(ctx context.Context, request OptUpdateOrganization2Req, params UpdateOrganization2Params) (UpdateOrganization2Res, error) {
	res, err := c.sendUpdateOrganization2(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateOrganization2(ctx context.Context, request OptUpdateOrganization2Req, params UpdateOrganization2Params) (res UpdateOrganization2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateOrganization (2)"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/api/organizations/{organization_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateOrganization2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/organizations/"
	{
		// Encode "organization_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organization_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOrganization2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "UpdateOrganization2", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "UpdateOrganization2", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateOrganization2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOrganizationMember invokes updateOrganizationMember operation.
//
// Updates a member in a given organization.
//
// PUT /api/organizations/{organization_name}/members/{user_name}
func (c *Client) UpdateOrganizationMember(ctx context.Context, request OptUpdateOrganizationMemberReq, params UpdateOrganizationMemberParams) (UpdateOrganizationMemberRes, error) {
	res, err := c.sendUpdateOrganizationMember(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateOrganizationMember(ctx context.Context, request OptUpdateOrganizationMemberReq, params UpdateOrganizationMemberParams) (res UpdateOrganizationMemberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateOrganizationMember"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/organizations/{organization_name}/members/{user_name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateOrganizationMember",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/organizations/"
	{
		// Encode "organization_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organization_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "user_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOrganizationMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "UpdateOrganizationMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "UpdateOrganizationMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateOrganizationMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateProject invokes updateProject operation.
//
// Updates a project with given parameters.
//
// PUT /api/projects/{account_handle}/{project_handle}
func (c *Client) UpdateProject(ctx context.Context, request OptUpdateProjectReq, params UpdateProjectParams) (UpdateProjectRes, error) {
	res, err := c.sendUpdateProject(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateProject(ctx context.Context, request OptUpdateProjectReq, params UpdateProjectParams) (res UpdateProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateProject"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateProject",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "UpdateProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "UpdateProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadCacheActionItem invokes uploadCacheActionItem operation.
//
// The endpoint caches a given action item without uploading a file. To upload files, use the
// multipart upload instead.
//
// POST /api/projects/{account_handle}/{project_handle}/cache/ac
func (c *Client) UploadCacheActionItem(ctx context.Context, request OptUploadCacheActionItemReq, params UploadCacheActionItemParams) (UploadCacheActionItemRes, error) {
	res, err := c.sendUploadCacheActionItem(ctx, request, params)
	return res, err
}

func (c *Client) sendUploadCacheActionItem(ctx context.Context, request OptUploadCacheActionItemReq, params UploadCacheActionItemParams) (res UploadCacheActionItemRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("uploadCacheActionItem"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/projects/{account_handle}/{project_handle}/cache/ac"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UploadCacheActionItem",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/api/projects/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "project_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectHandle))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/cache/ac"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadCacheActionItemRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, "UploadCacheActionItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}
		{
			stage = "Security:Cookie"
			switch err := c.securityCookie(ctx, "UploadCacheActionItem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Cookie\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUploadCacheActionItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
